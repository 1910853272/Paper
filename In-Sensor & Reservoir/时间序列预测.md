## 时间序列

时间信号在等间隔的时间点上被采样称为离散时间。离散时间系统的动态通常用差分方程来描述：$x_{t+1}=f(x_t)$

![iShot_2025-06-25_19.13.38](https://raw.githubusercontent.com/1910853272/image/master/img/202506251918609.png)

不规则采样的时间信号称为连续时间。连续时间系统的动态则使用微分方程来描述：$\frac{dt}{dx} = f(x)$

![iShot_2025-06-25_19.13.47](https://raw.githubusercontent.com/1910853272/image/master/img/202506251918757.png)

## 均方误差MSE

衡量预测数据与实际数据之间的差异$MSE = \frac{1}{T}\sum_{t=1}^{T} (X(t) - \hat{X}(t))^2$

![iShot_2025-06-25_19.38.09](https://raw.githubusercontent.com/1910853272/image/master/img/202506251938771.png)

## 储池Reservoir

```python
import numpy as np
from scipy import sparse

class Reservoir(object):    
    r"""
        构建一个储池并计算内部状态序列。
        
        参数:
        ------------
        n_internal_units : int (默认 ``100``)
            储池中的处理单元数。
        spectral_radius : float (默认 ``0.99``)
            储池连接权重矩阵的最大特征值。
            为了确保回声状态属性，需设置 ``spectral_radius <= leak <= 1``。
        leak : float (默认 ``None``)
            储池状态更新中的泄漏量。
            如果为 ``None`` 或 ``1.0``，则不使用泄漏。
        connectivity : float (默认 ``0.3``)
            非零连接权重的比例。
            在圆形储池中不使用此参数。
        input_scaling : float (默认 ``0.2``)
            输入连接权重的缩放比例。
            注意，输入权重是从 ``{-1,1}`` 中随机抽取的。
        noise_level : float (默认 ``0.0``)
            在状态更新中注入的高斯噪声标准差。
        circle : bool (默认 ``False``)
            如果为 ``True``，则生成一个确定性储池，采用圆形拓扑，每个连接权重相同。
        """

    def __init__(self, 
                 n_internal_units=100, 
                 spectral_radius=0.99, 
                 leak=None,
                 connectivity=0.3, 
                 input_scaling=0.2, 
                 noise_level=0.0, 
                 circle=False):
        """
        初始化储池的超参数，包括内部单元数、输入权重、噪声水平等。
        根据是否使用圆形拓扑来选择初始化方式。
        """
       
        # 初始化超参数
        self._n_internal_units = n_internal_units  # 储池中处理单元的数量
        self._input_scaling = input_scaling  # 输入连接权重的缩放比例
        self._noise_level = noise_level  # 噪声水平
        self._leak = leak  # 泄漏因子

        # 输入权重取决于输入数据的大小，在提供数据时设置
        self._input_weights = None

        # 根据是否使用圆形拓扑选择初始化内部权重
        if circle:
            self._internal_weights = self._initialize_internal_weights_Circ(
                    n_internal_units,
                    spectral_radius)
        else:
            self._internal_weights = self._initialize_internal_weights(
                n_internal_units,
                connectivity,
                spectral_radius)


    def _initialize_internal_weights_Circ(self, n_internal_units, spectral_radius):
        """
        使用圆形拓扑生成内部权重。
        圆形拓扑是确定性的，每个连接权重相同。
        """
        
        # 构造一个具有圆形拓扑的储池
        internal_weights = np.zeros((n_internal_units, n_internal_units))
        internal_weights[0,-1] = 1.0  # 连接第一个和最后一个单元
        for i in range(n_internal_units-1):
            internal_weights[i+1,i] = 1.0  # 连接所有相邻的储池单元
            
        # 调整谱半径（Spectral radius）
        E, _ = np.linalg.eig(internal_weights)  # 计算特征值
        e_max = np.max(np.abs(E))  # 找到最大的特征值
        internal_weights /= np.abs(e_max)/spectral_radius  # 标准化权重，确保谱半径符合要求
                
        return internal_weights
    
    
    def _initialize_internal_weights(self, n_internal_units,
                                     connectivity, spectral_radius):
        """
        使用稀疏、均匀随机拓扑生成内部权重。
        """
        
        # 生成稀疏、均匀分布的权重矩阵
        internal_weights = sparse.rand(n_internal_units,
                                       n_internal_units,
                                       density=connectivity).todense()

        # 确保非零值均匀分布在 [-0.5, 0.5] 范围内
        internal_weights[np.where(internal_weights > 0)] -= 0.5
        
        # 调整谱半径
        E, _ = np.linalg.eig(internal_weights)  # 计算特征值
        e_max = np.max(np.abs(E))  # 找到最大的特征值
        internal_weights /= np.abs(e_max)/spectral_radius  # 标准化权重，确保谱半径符合要求       

        return internal_weights


    def _compute_state_matrix(self, X, n_drop=0, previous_state=None):
        """
        计算输入数据 X 对应的储池状态。
        
        参数:
        X : np.ndarray
            输入数据，形状为 [N, T, V]，其中 N 为时间序列的数量，T 为每个时间序列的长度，V 为每个时间点的变量数。
        n_drop : int (默认是 ``0``)
            洗脱期，即因暂态效应而需要丢弃的初始样本数量。
        previous_state : np.ndarray (默认是 ``None``)
            储池的初始状态。如果为 ``None``，则使用零向量初始化状态。
        """

        N, T, _ = X.shape  # 提取输入数据的维度
        if previous_state is None:
            previous_state = np.zeros((N, self._n_internal_units), dtype=float)  # 如果没有提供初始状态，则使用零向量初始化

        # 储存矩阵，存储每个时间步的状态
        if T - n_drop > 0:
            window_size = T - n_drop
        else:
            window_size = T
        state_matrix = np.empty((N, window_size, self._n_internal_units), dtype=float)

        # 遍历时间步骤，计算每个时间步的状态
        for t in range(T):
            current_input = X[:, t, :]  # 获取当前时间步的输入

            # 计算当前状态
            state_before_tanh = self._internal_weights.dot(previous_state.T) + self._input_weights.dot(current_input.T)

            # 添加噪声
            state_before_tanh += np.random.rand(self._n_internal_units, N)*self._noise_level

            # 应用非线性激活函数（tanh）和泄漏（可选）
            if self._leak is None:
                previous_state = np.tanh(state_before_tanh).T
            else:
                previous_state = (1.0 - self._leak)*previous_state + np.tanh(state_before_tanh).T

            # 存储状态（在丢弃期之后）
            if T - n_drop > 0 and t > n_drop - 1:
                state_matrix[:, t - n_drop, :] = previous_state
            elif T - n_drop <= 0:
                state_matrix[:, t, :] = previous_state

        return state_matrix


    def get_states(self, X, n_drop=0, bidir=True, initial_state=None):
        r"""
        计算储池状态并返回。

        参数:
        ------------
        X : np.ndarray
            时间序列数据，形状为 ``[N,T,V]``，其中 ``N`` 为时间序列的数量，``T`` 为每个时间序列的长度，``V`` 为每个时间点的变量数。
        n_drop : int (默认是 ``0``)
            洗脱期，即因暂态效应而需要丢弃的初始样本数量。
        bidir : bool (默认是 ``True``)
            如果为 ``True``，则使用双向储池。
        initial_state : np.ndarray (默认是 ``None``)
            初始化储池的第一个状态。如果为 ``None``，则使用零向量初始化状态。

        返回:
        ------------
        states : np.ndarray
            储池状态，3D 数组，形状为 ``[N,T,n_internal_units]``，其中 ``N`` 为时间序列的数量，``T`` 为每个时间序列的长度，``n_internal_units`` 为储池的处理单元数量。
        """

        N, T, V = X.shape  # 获取时间序列的维度
        if self._input_weights is None:
            # 初始化输入权重，如果尚未设置
            self._input_weights = (2.0*np.random.binomial(1, 0.5 , [self._n_internal_units, V]) - 1.0)*self._input_scaling

        # 计算储池状态序列
        states = self._compute_state_matrix(X, n_drop, previous_state=initial_state)
    
        # 计算时间反转输入的储池状态（双向储池）
        if bidir is True:
            X_r = X[:, ::-1, :]  # 时间反转输入
            states_r = self._compute_state_matrix(X_r, n_drop)  # 计算反向储池状态
            states = np.concatenate((states, states_r), axis=2)  # 拼接正向和反向储池状态

        return states
```

![iShot_2025-06-26_14.14.16](https://raw.githubusercontent.com/1910853272/image/master/img/202506261415940.png)

![iShot_2025-06-26_14.14.36](https://raw.githubusercontent.com/1910853272/image/master/img/202506261415037.png)

![iShot_2025-06-26_14.14.57](https://raw.githubusercontent.com/1910853272/image/master/img/202506261415316.png)

![d24f77cad5c2b023a1a300b16941c1b7bf93368772cd87719b97663eed94bf6f](https://raw.githubusercontent.com/1910853272/image/master/img/202506261419792.png)

## 非线形动力学系统

### 动力学系统

x(t) 和 y(t)是系统的两个变量，而 $\alpha$ 和 $\beta$是系统的参数。系统的变量会随时间变化，而参数则保持不变.

![iShot_2025-06-26_14.30.24](https://raw.githubusercontent.com/1910853272/image/master/img/202506261430347.png)

### 线性增长模型

![iShot_2025-06-26_14.37.55](https://raw.githubusercontent.com/1910853272/image/master/img/202506261438350.png)

### 引入非线性项 (1 - x)

![iShot_2025-06-26_14.42.55](https://raw.githubusercontent.com/1910853272/image/master/img/202506261443059.png)

![iShot_2025-06-26_14.43.27](https://raw.githubusercontent.com/1910853272/image/master/img/202506261443371.png)

### 不同参数 r 值引起系统变化

**当 r < 1** 时，系统趋向于一个稳定的固定点，称为**一维吸引子**。

![iShot_2025-06-26_14.51.27](https://raw.githubusercontent.com/1910853272/image/master/img/202506261451167.png)

**当 1< r < 3** 时，系统的行为开始出现周期性波动，称为**分岔（Bifurcation）**。

![iShot_2025-06-26_14.52.12](https://raw.githubusercontent.com/1910853272/image/master/img/202506261453163.png)

**当r > 3** 时，系统开始进入**混沌**状态，呈现出不规则的行为。

![iShot_2025-06-26_14.52.34](https://raw.githubusercontent.com/1910853272/image/master/img/202506261453366.png)

![iShot_2025-06-26_14.54.01](https://raw.githubusercontent.com/1910853272/image/master/img/202506261454178.png)

![iShot_2025-06-26_14.54.11](https://raw.githubusercontent.com/1910853272/image/master/img/202506261454530.png)

 r 值增加，系统行为的复杂性增大，分岔现象愈加明显，最终进入**混沌**状态

![iShot_2025-06-26_14.57.37](https://raw.githubusercontent.com/1910853272/image/master/img/202506261457143.png)

### 混沌系统

**混沌**的表现形式是对初始条件高度敏感，即两个非常接近的初始条件会导致系统轨迹迅速分离。

![iShot_2025-06-26_15.02.45](https://raw.githubusercontent.com/1910853272/image/master/img/202506261502184.png)

### 高维连续时间系统

有包含两个或更多变量的系统。系统的维度由其变量的数量决定。

#### Lorenz system

![iShot_2025-06-26_15.14.37](https://raw.githubusercontent.com/1910853272/image/master/img/202506261514996.png)

![lorenz](https://raw.githubusercontent.com/1910853272/image/master/img/202506261513922.gif)