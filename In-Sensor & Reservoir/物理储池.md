# Mackey Glass

![iShot_2025-06-26_16.14.20](https://raw.githubusercontent.com/1910853272/image/master/img/202506261616808.png)

![iShot_2025-06-26_16.16.21](https://raw.githubusercontent.com/1910853272/image/master/img/202506261616191.png)

![iShot_2025-06-26_16.16.30](https://raw.githubusercontent.com/1910853272/image/master/img/202506261616279.png)

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import datetime
from sklearn.metrics import mean_squared_error
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
import signalz  # 用于Mackey-Glass混沌时间序列的生成
#  import time as t
#import user-defined functions
from functions import define_grid_graph_2,initialize_graph_attributes, mod_voltage_node_analysis, update_edge_weigths_2
from functions_reservoir import insert_R_to_graph, remove_R_from_graph

#%% SETUP
# 设置网络参数和模拟参数
g0_std = 0  # 电导初值的标准差（相对均值的百分比）
gmax_std = 0  # 最大电导的标准差（相对均值的百分比）
eta_p_std = 0  # 提升率的标准差（相对均值的百分比）
eta_d_std = 0  # 衰退率的标准差（相对均值的百分比）
round_decimal = 2  # 四舍五入的小数位数

# Mackey-Glass模型的控制参数
beta = 0.2
gamma = 0.9
tau = 18
n = 10

# 模拟的虚拟节点数量
num_virtual_nodes = 20
steps_training = 900 + num_virtual_nodes  # 训练步数
steps_forecasting = 1200  # 预测步数
init_duration = 400  # 初始化时长
mg_boundary = 0.6  # Mackey-Glass模型的边界
update_active = 0  # 是否启用更新步骤
init_active = 1  # 是否启用初始化步骤
update_steps_on = 100  # 更新步骤开启时间
update_steps_off = 200  # 更新步骤关闭时间

#%% NETWORK PARAMETER
# 网络参数设置（电导、增益、衰减等）
kp0 = 2.555173332603108574e-06  # 增益的初始值
kd0 = 6.488388862524891465e+01  # 衰减的初始值
eta_p = 3.492155165334443012e+01  # 提升率的初始值
eta_d = 5.590601016803570467e+00  # 衰退率的初始值
g_min = 1.014708121672117710e-03  # 最小电导值
g_max = 2.723493729125820492e-03  # 最大电导值
g0 = g_min  # 初始电导

frame = 1  # 网格的帧数（行/列）
inter_nodes = 1  # 网格中节点的间隔

ydim = frame*2+14+13*inter_nodes  # 图的维度
xdim = frame*2+14+13*inter_nodes
seed = 2  # 随机数种子

# 设定一个二维网格的节点列表
pad_rows = [[] for i in range(14)]
pad_rows[0] = [(frame+1)*(xdim-1)+(inter_nodes+1)*xdim*i for i in range(14)]
for i in range(1, 14):
    pad_rows[i] = [pad_rows[0][j]-(inter_nodes+1)*i for j in range(14)]
    
src = []  # 存储源节点的列表
for sublist in pad_rows:
    for item in sublist:
        src.append(item)

bias_nodes = [src[105]]  # 偏置节点
read_nodes = src[0:105] + src[106:]  # 读取节点
new_nodes = [xdim*ydim + nn for nn in range(196)]  # 新节点
gnd = [new_nodes[-1] + 1]  # 地线节点

R = [82] * 196  # 电阻值
V_read = 100e-3  # 读取电压
pulse_amplitude_min = 1  # 最小脉冲幅度
pulse_amplitude_max = 6  # 最大脉冲幅度

#%% NETWORK STIMULATION FOR TRAINING
# 训练过程中使用的刺激信号参数

delta_t_pot = 1e-3  # 激励信号的时间步长（秒）
delta_t_dep = 2e-3  # 衰减信号的时间步长（秒）
pot_points = 4  # 激励的点数
dep_points = 2  # 衰减的点数

steps_discard_initial_training = num_virtual_nodes  # 丢弃的初始训练步数

current_date_and_time = datetime.datetime.now().strftime("%Y_%m_%d_%Hh%Mm%Ss")  # 获取当前时间
current_date_and_time_string = str(current_date_and_time)  # 转换为字符串格式
folder = r'./out_data/Fig5/mackey_glass/simulation_' + current_date_and_time_string + '/'  # 输出文件夹路径
directory = './out_data/Fig5/mackey_glass/simulation_' + current_date_and_time_string + '/'  # 输出文件夹路径
if not os.path.exists(folder):
    os.makedirs(folder)

# 使用Mackey-Glass模型生成目标序列
try:
    
    if num_virtual_nodes > steps_discard_initial_training:
        raise Exception("ERROR: num virtual nodes too high with respect to steps_discard_initial_training")
    
    steps = steps_training + steps_forecasting  # 总步数
    
    # 生成Mackey-Glass目标序列
    mg_target = signalz.mackey_glass(steps, a=beta, b=0.8, c=gamma, d=tau, e=n, initial=mg_boundary)
    mg_target_norm = (mg_target - min(mg_target)) / ((max(mg_target) - min(mg_target)))  # 归一化
    
    plt.figure()
    plt.title("Mackey Glass Numeric Solution", fontsize=20)
    plt.plot(mg_target_norm, 'b', linewidth=2)  # 绘制Mackey-Glass目标序列
    plt.xlabel("steps", fontsize=15)  

    # 生成脉冲流信号
    pulse_stream = pulse_amplitude_min + mg_target_norm * (pulse_amplitude_max - pulse_amplitude_min)
    H_train = [[] for s in range(steps_training)]  # 用于存储训练过程中的状态
    H_train_read = [[] for s in range(steps_training)]  # 用于读取的状态
    output_train = np.zeros((steps_training, len(new_nodes)))  # 存储训练过程中的输出
    
    # 初始化网络
    G = define_grid_graph_2(xdim, ydim)
    initialize_graph_attributes(G, g0)
    
    # 训练过程
    for s in range(steps_training):
        pulse_stream[s] = round(pulse_stream[s], round_decimal)  # 对脉冲信号进行四舍五入
        
        input_list = []
        
        # 选择刺激节点，采用棋盘模式
        for count in range(196):
            if ((count % 2 == 0) & ((count // 14) % 2 == 0)) or ((count % 2 == 1) & ((count // 14) % 2 == 1)) :
                input_list += [pulse_stream[s]]
            else:
                input_list += [0]
               
        # 进行多个激励步
        for pp in range(pot_points):
            insert_R_to_graph(G, R, src, new_nodes, gnd)  # 向网络中插入电阻
            H_train[s] = mod_voltage_node_analysis(G, input_list, new_nodes, gnd)  # 电压节点分析
    
            remove_R_from_graph(G, R, new_nodes, gnd)  # 从网络中移除电阻
            G = update_edge_weigths_2(G, delta_t_pot / pot_points, g_min, g_min * g0_std, g_max, g_max * gmax_std, kp0, eta_p, eta_p * eta_p_std, kd0, eta_d, eta_d * eta_d_std)  # 更新电导
            
        # 存储训练输出结果
        for p in range(len(src)):
            output_train[s, p] = H_train[s].nodes[src[p]]['V']
            
        print(str(s) + "/" + str(steps_training) + " (training)")  # 输出当前训练进度
        
    #%% TRAINING
        
    # 选择读取输出的节点，采用棋盘模式
    read_idx = []  
    for count in range(196):
        if not(((count % 2 == 0) & ((count // 14) % 2 == 0)) or ((count % 2 == 1) & ((count // 14) % 2 == 1))) :
            read_idx += [count]
        
    # 生成训练输入数据
    train_in = np.zeros((steps_training - steps_discard_initial_training - 1, len(read_idx) + len(read_idx) * num_virtual_nodes))
    
    for s in range(len(train_in)):
        train_in[s, :] = np.hstack((np.reshape(output_train[steps_discard_initial_training + s, read_idx], (1, len(read_idx))), np.reshape(output_train[steps_discard_initial_training + s - num_virtual_nodes:steps_discard_initial_training + s, read_idx], (1, len(read_idx) * num_virtual_nodes))))
    
    # 生成训练输出数据
    train_out = np.zeros((steps_training - 1 - steps_discard_initial_training, 1))
    train_out[:, 0] = np.array(mg_target[steps_discard_initial_training + 1:steps_training])
    
    # 使用线性回归进行训练
    reg = LinearRegression().fit(train_in, train_out)
    pred_train = reg.predict(train_in)
    
    # 绘制训练结果
    plt.figure()
    plt.title('Training', fontsize=20)
    plt.plot(train_out, 'b', label='true')
    plt.plot(pred_train, 'r', label='predicted')
    plt.xlabel('Time-step', fontsize=20)
    plt.ylabel('Value', fontsize=20)
    plt.xticks(fontsize=15)
    plt.yticks(fontsize=15)  
    plt.legend(fontsize=15)   
    plt.grid()
    
    plt.savefig(directory + 'plot_training.png')
    np.savetxt(directory + 'plot_training.txt', np.hstack((np.reshape(pred_train, (len(pred_train), 1)), np.reshape(train_out, (len(train_out), 1)))))
    
    coef = reg.coef_  # 获取训练的线性回归系数
    
    #%% NETWORK STIMULATION FOR INITIALIZATION

    # 初始化过程
    if init_active:
        G_new = define_grid_graph_2(xdim, ydim)
        initialize_graph_attributes(G_new, g0)
        output_new = np.zeros((steps_training + steps_forecasting, len(src)))
        H_new = [[] for s in range(steps_training + steps_forecasting)]
        H_new_init = [[] for s in range(init_duration)]
        output_new_init = np.zeros((init_duration, len(src)))
        
        # 初始化过程
        for init in range(init_duration):
            input_list_target = []
            pulse_stream[init + steps_training - init_duration] = round(pulse_stream[init + steps_training - init_duration], round_decimal)
        
            for count in range(196):
                if ((count % 2 == 0) & ((count // 14) % 2 == 0)) or ((count % 2 == 1) & ((count // 14) % 2 == 1)) :
                    input_list_target += [pulse_stream[init + steps_training - init_duration]]
                else:
                    input_list_target += [0]
                
            # 进行多个激励步
            for pp in range(pot_points):
                insert_R_to_graph(G_new, R, src, new_nodes, gnd)
                H_new_init[init] = mod_voltage_node_analysis(G_new, input_list_target, new_nodes, gnd)
                remove_R_from_graph(G_new, R, new_nodes, gnd)
                G_new = update_edge_weigths_2(G, delta_t_pot / pot_points, g_min, g_min * g0_std, g_max, g_max * gmax_std, kp0, eta_p, eta_p * eta_p_std, kd0, eta_d, eta_d * eta_d_std)
            for p in range(len(src)):
                output_new_init[init, p] = H_new_init[init].nodes[src[p]]['V']
            print(str(init) + "/" + str(init_duration) + " (initialization)") 

        H_new[steps_training - init_duration:steps_training] = H_new_init
        output_new[steps_training - init_duration:steps_training, :] = output_new_init
    else:
        G_new = G
        H_new = [[] for s in range(steps_training + steps_forecasting)]
        H_new[:steps_training] = H_train
        output_new = np.zeros((steps_training + steps_forecasting, len(src)))
        output_new[:steps_training, :] = output_train

    #%% FORECASTING
    counter = 0
    
    # 进行预测
    for s in range(steps_training, steps_training + steps_forecasting):
        train_in_predict = np.zeros((1, len(read_idx) + len(read_idx) * num_virtual_nodes))
        
        train_in_predict[0, :] = np.hstack((np.reshape(output_new[s - 1, read_idx], (1, len(read_idx))), np.reshape(output_new[s - 2 - num_virtual_nodes:s - 2, read_idx], (1, len(read_idx) * num_virtual_nodes))))
    
        pulse_stream_new = reg.predict(train_in_predict)[0][0]
    
        pulse_stream_new = (pulse_stream_new - min(mg_target)) / ((max(mg_target) - min(mg_target)))
        pulse_stream_new = pulse_amplitude_min + pulse_stream_new * (pulse_amplitude_max - pulse_amplitude_min)
        pulse_stream_new = round(pulse_stream_new, round_decimal)
        
        input_list = []
        
        # 生成脉冲信号
        for count in range(196):
            if ((count % 2 == 0) & ((count // 14) % 2 == 0)) or ((count % 2 == 1) & ((count // 14) % 2 == 1)) :
                input_list += [pulse_stream_new]
            else:
                input_list += [0]
        
        pulse_stream[s] = round(pulse_stream[s], round_decimal)
         
        input_list_target = []
        
        # 更新脉冲信号
        for count in range(196):
            if ((count % 2 == 0) & ((count // 14) % 2 == 0)) or ((count % 2 == 1) & ((count // 14) % 2 == 1)) :
                input_list_target += [pulse_stream[s]]
            else:
                input_list_target += [0]
                
        # 进行多个激励步
        for pp in range(pot_points):
            insert_R_to_graph(G_new, R, src, new_nodes, gnd)
            
            if (update_active):
                if (counter < update_steps_off): 
                    H_new[s] = mod_voltage_node_analysis(G_new, input_list, new_nodes, gnd)
                else: 
                    H_new[s] = mod_voltage_node_analysis(G_new, input_list_target, new_nodes, gnd)
            else:
                H_new[s] = mod_voltage_node_analysis(G_new, input_list, new_nodes, gnd)
            
            remove_R_from_graph(G_new, R, new_nodes, gnd)
            G_new = update_edge_weigths_2(G, delta_t_pot / pot_points, g_min, g_min * g0_std, g_max, g_max * gmax_std, kp0, eta_p, eta_p * eta_p_std, kd0, eta_d, eta_d * eta_d_std)
        
        # 存储输出结果
        for p in range(len(src)):
            output_new[s, p] = H_new[s].nodes[src[p]]['V']
        
        counter += 1
        if counter == update_steps_off + update_steps_on:
            counter = 0
        print(str(s - steps_training) + "/" + str(steps_forecasting) + " (forecasting)") 
    
    #%% PLOT  
    # 绘制预测结果
    if init_active: # 包括初始化区域
        forecast_plot = np.zeros((init_duration + steps_forecasting, len(read_idx) + len(read_idx) * num_virtual_nodes))
        for s in range(len(forecast_plot)):
            forecast_plot[s, :] = np.hstack((np.reshape(output_new[steps_training - init_duration + s, read_idx], (1, len(read_idx))), np.reshape(output_new[steps_training - init_duration + s - num_virtual_nodes:steps_training - init_duration + s, read_idx], (1, len(read_idx) * num_virtual_nodes))))
    
    else: # 只绘制预测区域
        forecast_plot = np.zeros((steps_forecasting, len(read_idx) + len(read_idx) * num_virtual_nodes))
        for s in range(len(forecast_plot)):
            forecast_plot[s, :] = np.hstack((np.reshape(output_new[steps_training + s, read_idx], (1, len(read_idx))), np.reshape(output_new[steps_training + s - num_virtual_nodes:steps_training + s, read_idx], (1, len(read_idx) * num_virtual_nodes)))) 
    
    # 训练和预测结果绘制
    train_plot = np.zeros((steps_training - steps_discard_initial_training, len(read_idx) + len(read_idx) * num_virtual_nodes))
    for s in range(len(train_plot)):
        train_plot[s, :] = np.hstack((np.reshape(output_train[steps_discard_initial_training + s, read_idx], (1, len(read_idx))), np.reshape(output_train[steps_discard_initial_training + s - num_virtual_nodes:steps_discard_initial_training + s, read_idx], (1, len(read_idx) * num_virtual_nodes))))
    
    # 预测训练和测试数据
    pred_forecasting = reg.predict(forecast_plot)
    pred_train = reg.predict(train_plot)
    
    target = np.zeros((steps - steps_discard_initial_training, 1))
    target[:, 0] = np.array(mg_target[steps_discard_initial_training:])
    
    RMSE_train = mean_squared_error(target[0:steps_training - steps_discard_initial_training], pred_train, squared=False)  # 计算训练误差
    RMSE_forecast = mean_squared_error(target[steps_training - steps_discard_initial_training:], pred_forecasting[init_duration * init_active:], squared=False)  # 计算预测误差
        
    # 绘制预测结果
    plt.figure(figsize=(18, 9))
    plt.title('Forecasting', fontsize=20)
    plt.plot(target[steps_training - steps_discard_initial_training - init_active * init_duration:], 'b', label='true')
    plt.plot(pred_forecasting[:], 'r', label='predicted')
    if init_active:
        plt.axvline(x=init_duration, color='black', linewidth=2)
    plt.xlabel('Time-step', fontsize=20)
    plt.ylabel('Value', fontsize=20)
    plt.xticks(fontsize=15)
    plt.yticks(fontsize=15)  
    plt.legend(fontsize=15)   
    plt.grid()
    plt.savefig(directory + 'plot_forecast.png')
    
    # 保存结果
    np.savetxt(directory + 'plot_forecasting.txt', np.hstack((pred_forecasting[:], target[steps_training - steps_discard_initial_training - init_active * init_duration:])))
    np.savetxt(directory + 'output_train.txt', output_train)
    np.savetxt(directory + 'output_new.txt', output_new)
    np.savetxt(directory + 'coef.txt', coef)
    np.savetxt(directory + 'target.txt', target)
    np.savetxt(directory + 'predicted.txt', pred_forecasting)
    if init_active:
        np.savetxt(directory + 'output_new_init.txt', output_new_init)
    
    # 写入模拟参数到文件
    original_stdout = sys.stdout
    file_name = 'setup.txt'
    file = open(directory + file_name, 'w')
    
    sys.stdout = file 
    print('SIMULATION SETUP\n')
    
    print('tau = ' + str(tau))
    print('num_virtual_nodes = ' + str(num_virtual_nodes))
    print('steps_training = ' + str(steps_training))
    print('steps_forecasting = ' + str(steps_forecasting))
    print('init_active = ' + str(init_active))
    print('update_active = ' + str(update_active))
    print('init_duration = ' + str(init_duration))
    print('update_steps_on = ' + str(update_steps_on))
    print('update_steps_off = ' + str(update_steps_off))
    print('pulse_amplitude_min = ' + str(pulse_amplitude_min))
    print('pulse_amplitude_max = ' + str(pulse_amplitude_max))
    print('delta_t_pot = ' + str(delta_t_pot))
    print('\n')
    print('TRAIN RMSE: ' + str(RMSE_train))
    print('FORECAST RMSE: ' + str(RMSE_forecast))
    print('\n')
    print('Accuracy Train: ' + str(1 - RMSE_train))
    print('Accuracy Forecast: ' + str(1 - RMSE_forecast))
    
    file.close()
    sys.stdout = original_stdout 
    
except Exception as e:
    original_stdout = sys.stdout
    file_name = 'error.txt'
    file = open(directory + file_name, 'w')
    
    sys.stdout = file 
    
    print("ERROR")
    print(e)
    print('\n')
    print('SIMULATION SETUP\n')
    
    print('tau = ' + str(tau))
    print('num_virtual_nodes = ' + str(num_virtual_nodes))
    print('steps_training = ' + str(steps_training))
    print('steps_forecasting = ' + str(steps_forecasting))
    print('init_active = ' + str(init_active))
    print('update_active = ' + str(update_active))
    print('init_duration = ' + str(init_duration))
    print('update_steps_on = ' + str(update_steps_on))
    print('update_steps_off = ' + str(update_steps_off))
    print('pulse_amplitude_min = ' + str(pulse_amplitude_min))
    print('pulse_amplitude_max = ' + str(pulse_amplitude_max))
    print('delta_t_pot = ' + str(delta_t_pot))
                                   
    file.close()
    sys.stdout = original_stdout 

```

# 动态忆阻器储池计算

![iShot_2025-06-26_16.28.59](https://raw.githubusercontent.com/1910853272/image/master/img/202506261630284.png)

![iShot_2025-06-26_16.29.19](https://raw.githubusercontent.com/1910853272/image/master/img/202506261630416.png)

![iShot_2025-06-26_16.29.39](https://raw.githubusercontent.com/1910853272/image/master/img/202506261630305.png)

```matlab
%% I-V Characteristics of Memristor
clc;
clear;

% ----------------------Model Parameters----------------------
% para 包含了忆阻器的模型参数
para.r = 0.99; % 导电状态更新的衰减因子
para.G0 = 0.5; % 初始导电状态
para.Kp = 9.13; % 正向电流的增益
para.Kn = 0.32; % 负向电流的增益
para.alpha = 0.23; % 控制电压对导电状态的影响的系数

% ----------------------Voltage Sequence----------------------
% 电压序列的最小值和最大值
Vmin = -3;
Vmax = 3;
inv = 0.099; % 电压序列的步长

% 生成电压序列 V
V = -[0:inv:Vmax-inv, Vmax:-inv:Vmin+inv, Vmin:inv:0]; 

% ----------------------Start Simulation----------------------
% 计算电流和导电状态
step = length(V); % 电压序列的长度
I = zeros(1, step); % 初始化电流数组
G = para.G0; % 初始化导电状态为 G0

for i = 1:step
    % 使用 DynamicMemristor 函数计算每个电压点的电流和导电状态
    [I(i), G] = DynamicMemristor(V(i), G, para);
end

% ----------------------Experimental Data----------------------
% 加载实验数据用于对比
load('exdata.mat');

% ----------------------Plot----------------------
% 绘制电压-电流特性曲线
figure;
semilogy(V, abs(I)+10^-5, 'b'); % 模拟结果，使用对数坐标绘制
hold on;
semilogy(Vex, Iex, 'r'); % 实验数据，红色线
str1 = '\color{blue}Simulation'; % 模拟标签
str2 = '\color{red}Experiment'; % 实验标签
lg = legend(str1, str2); % 图例
set(lg, 'box', 'off'); % 不显示图例框
xlabel('Voltage (V)'); % X轴标签
ylabel('Current (μA)'); % Y轴标签
axis([-3, 3, -inf, inf]); % 设置坐标轴范围
set(gca, 'FontName', 'Arial', 'FontSize', 20); % 设置字体
set(gcf, 'unit', 'normalized', 'position', [0.2,0.2,0.3,0.45]); % 设置图形窗口位置

%% Waveform classification
clear;
clc;

% ----------------------Model Parameters----------------------
para.r = 0.99;
para.G0 = 0.5;
para.Kp = 9.13;
para.Kn = 0.32;
para.alpha = 0.23;

% ----------------------DM_RC Parameters----------------------
ML = 4; % 每个输入信号的维度
N = 10; % 模拟器的节点数量
Vmax = 3; % 最大电压
Vmin = -2; % 最小电压

% ----------------------DATASET----------------------
sample = 8; % 每个周期的样本长度
step = 2000; % 总步骤数
Data = zeros(1, 2*step); % 初始化数据
p1 = sin(pi*2*(0:sample-1)/sample); % 周期信号p1
p2(1:sample/2) = 1; % 周期信号p2（前半部分为1）
p2(sample/2+1:sample) = -1; % 后半部分为-1
for i = 1:2*step/sample
    q = unidrnd(2); % 随机选择1或2
    if q == 1
        Data(sample*(i-1)+1:sample*i) = p1; % 如果是1，使用周期信号p1
        Label(sample*(i-1)+1:sample*i) = 0; % 标签为0
    else
        Data(sample*(i-1)+1:sample*i) = p2; % 如果是2，使用周期信号p2
        Label(sample*(i-1)+1:sample*i) = 1; % 标签为1
    end
end

% ----------------------TRAIN----------------------
% 初始化输入信号流
Input = Data(1:step);

% 生成目标标签
Target = Label(1:step);

% mask过程，将信号通过掩膜处理
Mask = 2*unidrnd(2, N, ML)-3; % 随机生成掩膜
Input_ex = [];
for j = 1:N
    for i = 1:step
        % 将输入信号与掩膜相乘，得到最终的输入信号
        Input_ex(j, (i-1)*ML+1:ML*i) = Input(i)*Mask(j, :);
    end
end
UL = max(max(Input_ex)); % 最大值
DL = min(min(Input_ex)); % 最小值
% 归一化输入信号
Input_ex = (Input_ex-DL)/(UL-DL)*(Vmax - Vmin)+Vmin;

% 通过忆阻器计算输出
memout = [];
G = para.G0;
for i = 1:length(Input_ex(1, :))
    [memout(:,i), G] = DynamicMemristor(Input_ex(:,i), G, para); % 计算每个输入的输出
end

% 收集状态信息
states = [];
for i = 1:step
    a = memout(:, ML*(i-1)+1:ML*i); % 按照每个输入的维度分离输出
    states(:, i) = a(:); % 存储每个时刻的状态
end
X = [ones(1,step); states]; % 为回归添加偏置项

% 线性回归计算输出权重
Wout = Target*pinv(X); % 使用伪逆求解权重

% ----------------------TEST----------------------
% 初始化输入流
Input = Data(step+1:end); % 获取测试数据
Target = Label(step+1:end); % 获取测试标签

% mask过程，将信号通过掩膜处理
Input_ex = [];
for j = 1:N
    for i = 1:step
        Input_ex(j, (i-1)*ML+1:ML*i) = Input(i)*Mask(j, :);
    end
end
UL = max(max(Input_ex)); % 最大值
DL = min(min(Input_ex)); % 最小值
Input_ex = (Input_ex-DL)/(UL-DL)*(Vmax - Vmin)+Vmin; % 归一化

% 通过忆阻器计算输出
memout = [];
states = [];
G = para.G0;
for i = 1:length(Input_ex(1, :))
    [memout(:, i), G] = DynamicMemristor(Input_ex(:,i),G,para); % 计算每个输入的输出
end

% 收集状态信息
for i = 1:step
    a = memout(:, ML*(i-1)+1:ML*i); % 分离输出
    states(:,i) = a(:); % 存储每个时刻的状态
end
X = [ones(1,step);states]; % 为回归添加偏置项

% 系统输出
Out = Wout*X; % 计算预测值
NRMSE = sqrt(mean((Out(10:end)-Target(10:end)).^2)./var(Target(10:end))); % 计算归一化均方根误差
sprintf('%s',['NRMSE:',num2str(NRMSE)])

% ----------------------PLOT----------------------
% 绘制输入信号和输出结果
figure;
subplot(2, 1, 1);
plot(Input, 'b', 'linewidth', 1); % 绘制输入信号
hold on;
plot(Input, '.r');
axis([0, 400, -1.2, 1.2])
ylabel('Input')
set(gca,'FontName', 'Arial', 'FontSize', 20);

subplot(2, 1, 2);
plot(Target, 'k', 'linewidth', 2); % 绘制目标信号
hold on;
plot(Out, 'r', 'linewidth',1); % 绘制输出信号
axis([0, 400, -0.2, 1.2])
str1 = '\color{black}Target';
str2 = '\color{red}Output';
lg = legend(str1, str2);
set(lg, 'Orientation', 'horizon', 'box', 'off');
ylabel('Prediction')
xlabel('Time (\tau)')
set(gca,'FontName', 'Arial', 'FontSize', 20);
set(gcf, 'unit', 'normalized', 'position', [0.2, 0.2, 0.6, 0.35]);

% ----------------------Spoken-digit Recognition----------------------
clc;
clear;
addpath('Auditory Toolbox\');

% ----------------------Model Parameters----------------------
para.r = 0.99;
para.G0 = 0.5;
para.Kp = 9.13;
para.Kn = 0.32;
para.alpha = 0.23;

% ----------------------DM_RC Parameters----------------------
ML = 10; % 每个输入的维度
N = 40; % 节点数量
Vmax = 3; % 最大电压
Vmin = 0; % 最小电压

% ----------------------Dataset----------------------
% 加载音频数据文件路径
% 该部分需要从实际数据集加载音频文件路径，并处理其数据

% ----------------------Cross-validation----------------------
% 交叉验证

```

